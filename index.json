[{"content":"This article is still being written, come back later! üôÇ\n","permalink":"https://edfloreshz.blog/articles/ownership/","summary":"In this article, we\u0026rsquo;ll be discussing what ownership is and what it means for Rust","title":"Understanding Ownership In Rust"},{"content":"In this article, we\u0026rsquo;ll be discussing what control flow is and how we can use it in Rust.\nDeciding whether or not to run some code depending on a condition and deciding to run some code repeatedly while a condition is true are basic building blocks in most programming languages.\nThe most common constructs that let you control the flow of execution of Rust code are if expressions and loops.\nif Expressions if expressions are one of the most useful features of programming languages, it allows us to provide a condition and execute code if that condition is met.\n An if expression allows you to branch your code depending on conditions. You provide a condition and then state, ‚ÄúIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.‚Äù - The Rust Book\n All if expressions start with the keyword if, which is followed by a condition.\nfn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026#34;condition was true\u0026#34;); } else { println!(\u0026#34;condition was false\u0026#34;); } } After the condition, there should be curly brackets {} that will contain the code to execute in case the given condition is met.\nOptionally, we can also include an else expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don‚Äôt provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code.\nIt‚Äôs also worth noting that the condition in this code must be a bool. If the condition isn‚Äôt a bool, we‚Äôll get an error.\nIn order to write a valid condition, you can use ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=. It\u0026rsquo;s also valid to evaluate the result of an operation.\nif 1 + 1 == 2 { println!(\u0026#34;1 + 1 is 2\u0026#34;); } Handling Multiple Conditions with else if You can have multiple conditions by combining if and else in an else if expression.\nfn main() { let number = 6; if number % 4 == 0 { println!(\u0026#34;number is divisible by 4\u0026#34;); } else if number % 3 == 0 { println!(\u0026#34;number is divisible by 3\u0026#34;); } else if number % 2 == 0 { println!(\u0026#34;number is divisible by 2\u0026#34;); } else { println!(\u0026#34;number is not divisible by 4, 3, or 2\u0026#34;); } } Using too many else if expressions can clutter your code, so if you have more than one, you might want to refactor your code. In a later article, we\u0026rsquo;ll talk about a powerful Rust branching construct called match for these cases.\nUsing if in a let Statement Because if is an expression, we can use it on the right side of a let statement:\nfn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\u0026#34;The value of number is: {}\u0026#34;, number); } This is useful when we don\u0026rsquo;t want to create a variable and then assign the value inside the conditional blocks, we can do it all in one single expression.\nRepetition with Loops It‚Äôs often useful to execute a block of code more than once. For this task, Rust provides several loops. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning.\nRust has three kinds of loops: loop, while, and for. Let‚Äôs try each one.\nRepeating Code with loop The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop. This is equivalent to using while true in C.\nfn main() { loop { println!(\u0026#34;again!\u0026#34;); } } When we run this program, we‚Äôll see again! printed over and over continuously until we stop the program manually. Fortunately, Rust provides another, more reliable way to break out of a loop. You can place the break keyword within the loop to tell the program when to stop executing the loop. This can be placed inside a conditional block.\nfn main() { let mut number = 3; loop { if number == 5 { break } else { number += 1; } } } Once number reaches the value 5, the break keyword will break out of the loop.\nReturning Values from Loops One of the uses of a loop is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want to be returned after the break expression you use to stop the loop; that value will be returned out of the loop so you can use it.\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;The result is {}\u0026#34;, result); } Before the loop, we declare a variable named counter and initialize it to 0. Then we declare a variable named result to hold the value returned from the loop. On every iteration of the loop, we add 1 to the counter variable, and then check whether the counter is equal to 10. When it is, we use the break keyword with the value counter * 2. After the loop, we use a semicolon to end the statement that assigns the value to result. Finally, we print the value in result, which in this case is 20.\nConditional Loops with while It‚Äôs often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs. When the condition ceases to be true, the program calls break, stopping the loop. This loop type could also be implemented using a combination of loop, if, else, and break. However, this pattern is so common that Rust has a built-in language construct for it, called a while loop.\nfn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number -= 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } This construct eliminates a lot of nesting that would be necessary if you used loop, if, else, and break, and it‚Äôs clearer. While a condition holds true, the code runs; otherwise, it exits the loop.\nLooping Through a Collection with for You could use the while construct to loop over the elements of a collection, such as an array.\nfn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index \u0026lt; 5 { println!(\u0026#34;the value is: {}\u0026#34;, a[index]); index += 1; } } Here, the code counts up through the elements in the array. It starts at index 0, and then loops until it reaches the final index in the array (that is, when index \u0026lt; 5 is no longer true). Running this code will print every element in the array.\nBut this approach is error-prone; we could cause the program to panic if the index length is incorrect. It‚Äôs also slow because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop.\nAs a more concise alternative, you can use a for loop and execute some code for each item in a collection.\nfn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026#34;the value is: {}\u0026#34;, element); } } We‚Äôve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.\nFor example, if you changed the definition of the a array to have four elements but forgot to update the condition to while index \u0026lt; 4, the code would panic. Using the for loop, you wouldn‚Äôt need to remember to change any other code if you changed the number of values in the array.\nSummary The safety and conciseness of for loops make them the most commonly used loop construct in Rust.\nEven in situations in which you want to run some code a certain number of times, as in a countdown, most Rustaceans would use a for loop. The way to do that would be to use a Range, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.\nHere‚Äôs what the countdown would look like using a for loop and another method we‚Äôve not yet talked about, rev, to reverse the range.\nfn main() { for number in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, number); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } What\u0026rsquo;s next? This was just a quick introduction to control flow, we will explore more about this in a later article.\nIn the next article, we\u0026rsquo;ll talk about Understanding Ownership. Rust is a very unique programming language and ownership is one of the reasons why.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","permalink":"https://edfloreshz.blog/articles/controlflow/","summary":"In this article, we\u0026rsquo;ll be discussing what control flow is and how we can use it in Rust","title":"Control Flow In Rust"},{"content":"In this article, we\u0026rsquo;ll be discussing what functions are and when to use them in Rust.\nAs some of us already know, functions are \u0026ldquo;self-contained\u0026rdquo; modules of code that accomplish a specific task. Generally, functions are used to encapsulate certain pieces of repetitive code that can later be used by other functions to execute said code without having to write it all over again.\nFunctions should be small, this is the first and the most important rule related to functions, you should keep them as short as possible. A shorter function will do less and as a consequence, it will be more easily understood and managed. You might be wondering: \u0026ldquo;How short should my functions be?\u0026rdquo;, unfortunately, there is no magic number here. In general, if you end up with a method longer than 10-15 lines of code you should take a look over it and see why it is so long. Functions should also do one thing, this will make it easier for you and others to manage your code and understand where a certain bug might be appearing, also, try using descriptive names.\n If you want to learn more about how to write good code, I recommend you read Clean Code by Robert C. Martin.\n Functions in Rust Rust code uses **snake_case **as the conventional style for function and variable names. In snake_case, all letters are lowercase, and underscores are used to separate words.\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); another_function(); } fn another_function() { println!(\u0026#34;Another function.\u0026#34;); } The curly brackets tell the compiler where the function body begins and ends. Note that we defined another_function after the main function in the source code; we could have defined it before as well. Rust doesn‚Äôt care where you define your functions, only that they‚Äôre defined somewhere. This is not the case with other languages like C/C++, where you need to define functions before the function that will call them.\nFunction Parameters If you\u0026rsquo;ve worked with functions before, you already know what parameters are for, but for those who haven\u0026rsquo;t, a parameter is simply data being sent to a function. As you may have already realized, functions are not in the same scope as the function that calls them, this means that they don\u0026rsquo;t have access to the same data. In order for the function to work, we need to send them the required data.\nAs an example, imagine a function add that takes two parameters, two numbers to add.\nfn add( x: u32, y: u32) -\u0026gt; u32 { x + y } Functions are declared using the fn keyword. Its arguments are type annotated, just like variables, and, if the function returns a value, the return type must be specified after an arrow -\u0026gt;.\nIf you come from another language, you might be wondering where the return statement and the ; are. With Rust, the final expression in the function will be used as the return value. Alternatively, the return statement can be used to return a value earlier from within the function, even from inside loops or if statements.\nTake a look at x + y, this is what\u0026rsquo;s called an expression, expressions evaluate to a resulting value, in this case, the sum of x and y. For instance, this function will return the resulting value of that expression.\nFunction definitions and variable declarations are statements; statements do not return values, therefore, you can‚Äôt assign a let statement to another variable:\nlet x = (let y = 6); This will result in an error:\nerror: expected expression, found statement (`let`) --\u0026gt; src/main.rs:2:14 | 1 | let x = (let y = 6); | ^^^ | = note: variable declaration using `let` is a statement Returning Values In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.\nIf we place a semicolon at the end of the final line containing x + y, changing it from an expression to a statement, we‚Äôll get an error:\nerror[E0308]: mismatched types --\u0026gt; src/main.rs:7:24 | 7 | fn add(x: u32, y: u32) -\u0026gt; u32 { | ---- ^^^ expected `u32 `, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression 8 | x + y; | - help: consider removing this semicolon error: aborting due to previous error The main error message, ‚Äúmismatched types,‚Äù reveals the core issue with this code. The definition of the function add says that it will return an i32, but statements don‚Äôt evaluate to a value, which is expressed by (), an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.\nWhat\u0026rsquo;s next? There is a lot more to learn about functions, this is just a quick introduction, we will explore functions in more detail in a later article.\nIn the next article, we\u0026rsquo;ll talk about Control Flow, it will allow us to express the way that execution components (statements, expressions, and declarations) are wired together to effect a computation.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","permalink":"https://edfloreshz.blog/articles/functions/","summary":"In this article, we\u0026rsquo;ll be discussing what control flow is and how we can use it in Rust","title":"Functions In Rust"},{"content":"In this article, we\u0026rsquo;ll be discussing the various data types in Rust.\nRust differs from languages like Python or JavaScript in many ways, Rust is what\u0026rsquo;s known as a strongly typed language, this means that every variable must have a predefined data type bound to it at compile-time, in weakly typed languages, you don\u0026rsquo;t have to explicitly define them because it makes conversions between unrelated types implicitly. Of course, this comes at a cost, while weakly typed languages have many advantages, speed isn\u0026rsquo;t one of them.\n Compile time is the time at which the source code is converted into executable code.\n Every value in Rust is of a certain data type, this tells Rust what kind of data is being used and how to manage it. There are two types of data in Rust, scalar and compound.\nThe compiler can usually infer what data type we want to use based on the value we assign to it and how we use it. In cases when many types are possible, such as when we convert text to a numeric type, we must add a type annotation:\nlet guess: u32 = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); Type annotations are added by using : followed by the data type, in this case u32, after the variable name. If we don‚Äôt add the type annotation here, we\u0026rsquo;ll get a compiler error:\nerror[E0282]: type annotations needed --\u0026gt; src/main.rs:2:9 | 2 | let guess = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); | ^^^^^ consider giving `guess` a type Scalar Types A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You might recognize these from other languages.\nInteger Types An integer is a number without a fractional component. Integers can be divided into two types: signed and unsigned.\nA signed integer is an integer that can be both positive and negative. This is as opposed to an unsigned integer, which can only be positive. Integers are represented as bytes, one byte is equivalent to 8 bits, which is the basic unit of information in computing.\nIn Rust, we have the following data types:\n   Length Signed Unsigned     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128    Each number represents the number of bits that can be allocated in that data type, for instance, when we declare a variable with u8, we are saying that our variable will not have negative numbers and can store up to 8 bits of information.\nEach signed variant can store numbers from -(2^(n - 1)) to 2^(n - 1) - 1 inclusive, where n is the number of bits that variant uses. So an i8 can store numbers from -(2^7) to 2^7 - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2^(n) - 1, so a u8 can store numbers from 0 to 2^(8) - 1, which equals 0 to 255.\n   Length From To     i8 -128 127   u8 0 255   i16 -32,768 32,767   u16 0 65,535    You can calculate the remaining ranges using Wolfram Alpha, just replace n in the equation with the number of bytes that the remaining data types can store.\nAdditionally, the isize and usize types depend on the kind of computer your program is running on: 64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-bit architecture.\nInteger Literals You can write integer literals in any of the forms shown in the next table. Note that all number literals except the byte literal allow a type suffix, such as 57u8, and _ as a visual separator, such as 1_000.\n   Number literals Example     Decimal 98_222   Hex 0xff   Octal 0o77   Binary 0b1111_0000   Byte u8 only b'A'    Integer Overflow Let‚Äôs say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur. An integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits.\nWhen you\u0026rsquo;re debugging your app, this will cause it to panic and exit, but if this code is compiled as -- release, two‚Äôs complement wrapping will occur. This means that values greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the minimum of the values the type can hold. In the case of a u8, 256 becomes 0, 257 becomes 1, and so on.\nFloating-Point Types Rust also has two primitive types for floating-point numbers, which are numbers with decimal points, f32 and f64. Here\u0026rsquo;s how you declare a variable of type floating-point.\nfn main() { let x = 2.0; // Rust can infer this is of type f64 when we use a decimal point.  let y: f32 = 3.0; // We need to specify it as f32 because f64 is the default. } The Boolean Type The boolean type, as in most programming languages, has only two possible values, true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool.\nfn main() { let t = true; let f: bool = false; // with explicit type annotation } You can also declare boolean types by using logical operators.\nfn main() { let yes = true || true; let no = true \u0026amp;\u0026amp; false; println!(\u0026#34;{} and {}\u0026#34;, yes, no); // true and false } The Character Type Rust doesn\u0026rsquo;t only work with numbers, it has letters too!\nfn main() { let c = \u0026#39;z\u0026#39;; let z = \u0026#39;‚Ñ§\u0026#39;; let heart_eyed_cat = \u0026#39;üòª\u0026#39;; } Rust‚Äôs char type is the language‚Äôs most primitive alphabetic type, are four bytes in size, and represent a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust.\nNote that char literals are specified with single quotes, as opposed to string literals, which use double-quotes.\nNumeric Operations Rust supports the basic mathematical operations you‚Äôd expect for all of the number types: addition, subtraction, multiplication, division, and remainder.\nThe following example shows how to use all of them:\nfn main() { // addition  let sum = 5 + 10; // subtraction  let difference = 95.5 - 4.3; // multiplication  let product = 4 * 30; // division  let quotient = 56.7 / 32.2; // remainder  let remainder = 43 % 5; } Compound Types Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.\nThe Tuple Type A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.\nWe create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don‚Äôt have to be the same.\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is: {}\u0026#34;, y); // 6.4 } This program first creates a tuple and binds it to the variable tup. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.\nIn addition to destructuring through pattern matching, we can access a tuple element directly by using a period . followed by the index of the value we want to access. For example:\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; // 500  let six_point_four = x.1; // 6.4  let one = x.2; // 1 } The Array Type Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type.\nIn Rust, the values going into an array are written as a comma-separated list inside square brackets:\nfn main() { let a = [1, 2, 3, 4, 5]; let months = [\u0026#34;January\u0026#34;, \u0026#34;February\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;June\u0026#34;, \u0026#34;July\u0026#34;, \u0026#34;August\u0026#34;, \u0026#34;September\u0026#34;, \u0026#34;October\u0026#34;, \u0026#34;November\u0026#34;, \u0026#34;December\u0026#34;]; } Arrays are useful when you want your data allocated on the stack rather than the heap (you can learn more about this here) or when you want to ensure you always have a fixed number of elements.\nYou would write an array‚Äôs type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:\nlet a: [i32; 5] = [1, 2, 3, 4, 5]; Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\nAccessing Array Elements An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; // 1  let second = a[1]; // 2 } In this example, the variable named first will get the value 1, because that is the value at index [0] in the array. The variable named second will get the value 2 from index [1] in the array.\nInvalid Array Element Access What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:\nfn main() { let a = [1, 2, 3, 4, 5]; let index = 10; let element = a[index]; println!(\u0026#34;The value of element is: {}\u0026#34;, element); } Running this code using cargo run produces the following result:\n$ cargo run Compiling arrays v0.1.0 (file:///projects/arrays) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/arrays` thread \u0026#39;main\u0026#39; panicked at \u0026#39;index out of bounds: the len is 5 but the index is 10\u0026#39;, src/main.rs:5:19 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace. The compilation didn‚Äôt produce any errors, but the program resulted in a runtime error and didn‚Äôt exit successfully. When you attempt to access an element using indexing, Rust will check that the index you‚Äôve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.\nThis is the first example of Rust‚Äôs safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.\nWhat\u0026rsquo;s next? In the next article, we\u0026rsquo;ll talk about functions to provide better modularity for your application.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","permalink":"https://edfloreshz.blog/articles/datatypes/","summary":"In this article, we\u0026rsquo;ll be discussing the various data types in Rust","title":"Data Types In Rust"},{"content":"In the last article, we talked about how to use Cargo for Rust projects and highlighted some of its most common commands. We are now going to go further and start talking about variables and mutability.\nOne of Rust\u0026rsquo;s main features is that variables are immutable by default, which means that values cannot change once set. This might seem odd at first, mainly because we sometimes need to change values in order to make our program work, but fear not, you can still make them mutable!\nI will try to solve most of the questions you may have about this, let\u0026rsquo;s dive right in!\nVariables By definition, a variable is a value that can change, if you\u0026rsquo;ve been taught programming before or learned by yourself, this might sound familiar.\nRust takes a different approach when it comes to variables, instead of assuming that values will change throughout the lifespan of the program, it assumes that they won\u0026rsquo;t and lets you, the programmer, decide which values will change. This lets you write your code in a way that takes advantage of the safety guarantees Rust offers.\nWhen a variable is immutable, once a value is bound to a name, you cannot change that value. Let\u0026rsquo;s see an example:\nfn main() { let x = 5; println!(\u0026#34;The value is: {}\u0026#34;, x); x = 6; println!(\u0026#34;The value is: {}\u0026#34;, x); } Save and run the program using cargo run.You should receive an error message:\n$ cargo run Compiling variables v0.1.0 (file:///projects/variables) error[E0384]: cannot assign twice to immutable variable `x` --\u0026gt; src/main.rs:4:5 | 2 | let x = 5; | - | | | first assignment to `x` | help: make this binding mutable: `mut x` 3 | println!(\u0026#34;The value of x is: {}\u0026#34;, x); 4 | x = 6; | ^^^^^ cannot assign twice to immutable variable error: aborting due to previous error For more information about this error, try `rustc --explain E0384`. error: could not compile `variables`. To learn more, run the command again with --verbose. Look closely for error[E0384]: cannot assign twice to immutable variable 'x', this might\u0026rsquo;ve already given you a clue of what\u0026rsquo;s going on, but I\u0026rsquo;ll go through the error message and explain what\u0026rsquo;s going on in detail.\nWhat this error is basically telling us is that we tried to change an immutable variable and since this is not allowed the compiler will yell at us, it might appear like a simple thing to complain about, but the Rust compiler is very strict and for good reason, the error messages only mean your program isn\u0026rsquo;t safely doing what you want it to do yet.\nThe Rust compiler not only checks for errors, but it also tries to give you suggestions on how to solve them, check for lines like this:\nhelp: make this binding mutable: 'mut x'  Also, look for error codes in your compiler output, it might give you a better clue of what\u0026rsquo;s going on. For example, error[E0384] is something you can look up and get help with, try either using rustc --explain E0384 or find the error code in the Rust Compiler Error Index.\nOkay! Let\u0026rsquo;s fix our program, taking all of the previous suggestions into account, you might\u0026rsquo;ve realized by now that we are missing a keyword in our variable definition, mut, this keyword will make our variables mutable:\nfn main() { let mut x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); } Therefore, you are now allowed to reassign the value for our x variable.\nDifferences between variables and constants By now, if you have used constants before you might\u0026rsquo;ve thought\n \u0026ldquo;Immutable variables are basically constants then?\u0026rdquo;\n Well, not exactly, first, you aren\u0026rsquo;t allowed to use mut with constants, they aren\u0026rsquo;t just immutable by default, they are immutable forever.\nYou declare constants with the const keyword and you must always annotate the data type, like so:\nconst MAX_POINTS: u32 = 100_000; // Rust\u0026#39;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.\nShadowing There is a concept in Rust that most of you might be unfamiliar with, it\u0026rsquo;s called shadowing, it allows you to declare a new variable with the same name as a previous variable. This is useful in cases where you want to take a previous value of a variable and assign it to itself with some modification, here\u0026rsquo;s an example:\nfn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\u0026#34;The value of x is: {}\u0026#34;, x); } As you can see, this program first binds x to a value of 5. Then it shadows x by repeating let x =, taking the original value, and adding 1 so the value of x is then 6. Then, the third let statement also shadows x, multiplying the previous value by 2 to give x a final value of 12. When we run this program, it will output the following:\n$ cargo run Compiling variables v0.1.0 (file:///projects/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/variables` The value of x is: 12 Shadowing is different from marking a variable as mut because we\u0026rsquo;ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed. By using shadowing, we are also able to reuse the same name as the previous variable.\nWhat\u0026rsquo;s next? In the next article, we\u0026rsquo;ll talk about data types.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","permalink":"https://edfloreshz.blog/articles/varmut/","summary":"In the last article, we talked about how to use Cargo for Rust projects and highlighted some of its most common commands. We are now going to go further and start talking about variables and mutability.","title":"Variables And Mutability In Rust"},{"content":"In the last article, we talked about the basics to get started with Rust, we even wrote our first, very simple program. We are now going to discuss how can we use Cargo, one of the tools we talked about that comes with Rust.\nCargo is Rust\u0026rsquo;s package manager, with it, you can add dependencies to your projects, for instance, let\u0026rsquo;s say you need to generate random numbers, well, there\u0026rsquo;s a crate for that.\ncrates.io is a website where you can explore every available crate for your projects, it gives you access to documentation, statistics, and many more things. We\u0026rsquo;ll discuss more on how can we add a crate to our project later.\nHello Cargo In the last article, we created a file called main.rs, wrote the main function with some very basic functionality, and used rustc to compile and then ran it. Now, we are going to focus on using the rand crate to make a random number generator, our main focus here will be using cargo to make all of this easier.\nTo start a new project, navigate to your projects directory and type:\ncargo new randgen We\u0026rsquo;ll see that there\u0026rsquo;s now a new directory called randgen in our projects folder. When we enter, we will see a file called Cargo.toml, which is our project\u0026rsquo;s configuration file, it looks something like this:\n[package] name = \u0026#34;randgen\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Your Name \u0026lt;you@example.com\u0026gt;\u0026#34;] edition = \u0026#34;2018\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] And the src directory, where all of our source files will live.\nLet\u0026rsquo;s open src/main.rs and see what\u0026rsquo;s in there:\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } Looks familiar?\nDependencies We are now going to include the rand crate to our file:\nuse rand::Rng; fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } When we want to include a dependency in one of our files, we need to use the use keyword, followed by our crate\u0026rsquo;s name and subsequent modules, in this case, the Rng trait, we separate them by using a ::.\n We\u0026rsquo;ll talk about traits in a future article.\n Create a random number We haven\u0026rsquo;t talked about variables yet, we\u0026rsquo;ll cover the basic here and go more in-depth in a later article.\nLet\u0026rsquo;s make a variable to store our random number:\nuse rand::Rng; fn main() { let random = rand::thread_rng().gen_range(1, 101); println!(\u0026#34;The random number is {}!\u0026#34;, random); } We use the let keyword to create new variables, followed by their name, then we use = to assign a value to them. In this case, we\u0026rsquo;re assigning the value that rand::thread_rng().gen_range(1, 101) generates. Both thread_rng() and gen_range() are functions, which return a value.\nthread_rng() returns a lazily-initialized thread-local random number generator, which then calls gen_range(), a function that returns a random value that is in the range that was passed to the function as a parameter, in this case, 1, 100.\nWe then pass this variable to println! and we use a syntax we haven\u0026rsquo;t seen before:\nprintln!(\u0026#34;The random number is {}!\u0026#34;, random); That {} you see inside the text we\u0026rsquo;re printing is a placeholder for a value to fill in, in this case, the random variable. When we run this, we might encounter something like this:\nThe random number is 12! We don\u0026rsquo;t know exactly what number will be displayed, given that it is a random number.\nRunning the program Try running your program, but this time use Cargo to run it.\ncargo run Whoops! What did we miss?\nYou should\u0026rsquo;ve encountered something like this:\nerror[E0432]: unresolved import `rand` --\u0026gt; src/main.rs:1:5 | 1 | use rand::Rng; | ^^^^ use of undeclared crate or module `rand` error[E0433]: failed to resolve: use of undeclared crate or module `rand` --\u0026gt; src/main.rs:4:18 | 4 | let random = rand::thread_rng().gen_range(1, 101); | ^^^^ use of undeclared crate or module `rand` error: aborting due to 2 previous errors Remember that Cargo.toml configuration file we talked about at the beginning? That file manages what dependencies are loaded into your project, so we need to specify we want the rand crate in out project. Open it, look for [dependencies] and add rand = \u0026quot;0.7.3\u0026quot; below, the version number might change, be sure to use the one that fits your needs.\nThe file should look something like this now:\n[package] name = \u0026#34;randgen\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Your Name \u0026lt;you@example.com\u0026gt;\u0026#34;] edition = \u0026#34;2018\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] rand = \u0026#34;0.7.3\u0026#34; Try running the project now and you should see something like this now:\n$ cargo run Compiling cfg-if v0.1.10 Compiling ppv-lite86 v0.2.9 Compiling libc v0.2.77 Compiling getrandom v0.1.15 Compiling rand_core v0.5.1 Compiling rand_chacha v0.2.2 Compiling rand v0.7.3 Compiling randgen v0.1.0 (/home/eduardo/Developer/Projects/randgen) Finished dev [unoptimized + debuginfo] target(s) in 1.92s Running `target/debug/randgen` The random number is 22! Congratulations! This is your second program in Rust and you made use of an external crate and Cargo.\nCargo tips and tricks We only used one Cargo command in this article, but there are a lot more!\ncargo -\u0026gt; will list all of the available commands for you.\ncargo build -\u0026gt; will build your project, this includes downloading dependencies and compiling it, it will not run it.\ncargo check -\u0026gt; will check for syntax errors in your code, it will not compile nor run it. This is handy when you don\u0026rsquo;t want to wait for your program to compile in order to check for errors.\ncargo init -\u0026gt; will create a new cargo package in an existing directory.\ncargo install -\u0026gt; can be used to install a Rust binary, such as gitui, which is a terminal-ui for git written entirely in Rust by Stephan Dilly.\ncargo uninstall -\u0026gt; will uninstall a Rust binary.\nIf you\u0026rsquo;d like to get a more in-depth look at Cargo you can check out the Cargo Guide.\nWhat\u0026rsquo;s next? In the next article, we\u0026rsquo;ll talk about variables and mutability.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","permalink":"https://edfloreshz.blog/articles/cargo/","summary":"We are now going to discuss how can we use Cargo, one of the tools we talked about that comes with Rust","title":"Let's Talk About Cargo For Rust Projects"},{"content":"This is the first in a series of articles to help developers understand Rust better, I will be covering most of what you can find in The Rust Book, in a more synthesized and concise way. I will start with the basics and build my way up to more complex topics.\nDisclaimer This course is intended for people who have a basic understanding of programming languages, preferably those who have written code before, this doesn\u0026rsquo;t mean you can\u0026rsquo;t follow along if you have no experience, just that it will be harder to understand some concepts.\nDon\u0026rsquo;t get discouraged if you fail to understand the concepts presented in these articles, I\u0026rsquo;d like to encourage you to ask questions, if you need assistance you can send me a message.\nTry Rust If you\u0026rsquo;re not comfortable installing Rust, you can try Rust in the browser!\nInstalling Rust If you use Windows, you can download the installer here.\nInstall Rust by pasting this in your terminal if you\u0026rsquo;re on a UNIX based system\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh  You will be presented with the following\nWelcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/username/.rustup This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/username/.cargo This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup, and other commands will be added to Cargo's bin directory, located at: /home/username/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/username/.profile /home/username/.zprofile /home/username/.bash_profile You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Type your desired method of installation and let the installer do its thing. Once it\u0026rsquo;s done, open a new instance of your terminal and type rustc, you should see something like this\nUsage: rustc [OPTIONS] INPUT Options: -h, --help Display this message --cfg SPEC Configure the compilation environment -L [KIND=]PATH Add a directory to the library search path. [...]  What just happened? You just installed Rust, the installer doesn\u0026rsquo;t only install the compiler, it comes with a set of tools that will help you out in your journey as a Rustacean, I\u0026rsquo;ll explain what they all do.\n rustc -\u0026gt; This is the Rust compiler, it takes the code you\u0026rsquo;ve written and turns it into machine code, making it understandable by your machine and therefore, executable. rustup -\u0026gt; This tool manages Rust, it can update and remove the tools or personalize your preferences. cargo -\u0026gt; Cargo is Rust\u0026rsquo;s package manager, it manages dependencies for projects and can help you create new projects from scratch. clippy -\u0026gt; Clippy is a collection of lints to catch common mistakes and improve your code. Linters are static code analysis tools used to flag various kinds of programming errors. rust-docs -\u0026gt; Is a tool used to generate documentation for your code, this saves you a lot of time. rust-std -\u0026gt; This is the Rust Standard Library, a collection of crates you have available when writing your programs. Every Rust program is called a crate. rustfmt -\u0026gt; A tool for formatting Rust code according to style guidelines. This one is pretty cool.  Managing Rust There are various things **rustup ** can do for you, such as update rustup update and uninstall Rust rustup self uninstall. We will discuss more this tool in a future article.\nWrite Your First Program Let\u0026rsquo;s get coding! Start by making a directory for your files.\nmkdir ~/developer cd ~/developer mkdir hello_world cd hello_world Inside that directory, create a file by either touch main.rs and opening it or using your preferred text editor.\nvim main.rs nano main.rs emacs main.rs And write the following:\nfn main() { println!(\u0026quot;Hello, world\u0026quot;); }  fn is the keyword for defining new functions and main is the name for that function, also the entry point for our program. println! is a macro, not a function, we will learn more about macros in a future article but for now, know that println! will print \u0026ldquo;Hello, world\u0026rdquo; to the terminal.\nCompiling And Executing It\u0026rsquo;s time to run our program, save your file and exit your text editor, we will use rustc to make a binary of our file.\nrustc main.rs You will notice a new file with the name main was created, this is our binary file, to run it type:\n./main You should see Hello, world on your screen.\nCongratulations! You\u0026rsquo;ve successfully written, compiled, and ran your first Rust program.\nConclusion Rust\u0026rsquo;s main objective is to create a language that empowers everyone to build reliable and efficient software, in the next articles, we will learn how to make use of Rust\u0026rsquo;s best features, such as cargo, you can check the next article.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter.\n","permalink":"https://edfloreshz.blog/articles/getstarted/","summary":"This is the first in a series of articles to help developers understand Rust better","title":"How to get started with Rust?"},{"content":"As developers, we sometimes require to test our software on different platforms, this can be hard to do especially if you don\u0026rsquo;t own a Mac, fortunately, there is a way to do exactly that.\nFor the past months I\u0026rsquo;ve been using Windows, Linux, and macOS in a single machine, here\u0026rsquo;s how I did it.\nDisclaimer In order to get this working, you have to meet the following requirements:\n At least two hard drive units to install the operating systems, but if you prefer to have three separate disks for each system that works too. Integrated Intel graphics or dedicated AMD Radeon graphics. Intel (Ivy Bridge or higher) or AMD (Bulldozer or higher) processor. Basic knowledge of command lines and how to use a terminal.  Windows Let\u0026rsquo;s start with Windows.\n Download the Media Creation Tool from Microsoft\u0026rsquo;s website Create a bootable USB using Media Creation Tool. Boot into the USB and install Windows in either of the drives. Boot into Windows.  This is the first step, let\u0026rsquo;s get to Linux.\nLinux This guide will focus on installing Ubuntu, as it is the most popular distribution, but you can choose any distribution you like, my recommendation is PopOS! for developers.\n Download the ISO from Canonical\u0026rsquo;s website Create a bootable USB using Rufus. Boot into the USB and install Linux either alongside Windows in the same drive in case you have two drives or in the second drive assuming you have three drives. Boot into Linux.  Once you\u0026rsquo;ve successfully booted your system, follow the instructions to install macOS.\nmacOS Now you have a dual-boot between Windows and Linux, it\u0026rsquo;s time to inject macOS into the mix. There is no standard way of creating the bootable USB, every computer requires manual setup.\nIf you\u0026rsquo;d like to follow the visual guide, check out this link.\nIf you\u0026rsquo;d like to follow the written guide, check out this link.\n Follow either of the guides mentioned before to create the bootable USB. Once you\u0026rsquo;ve created the USB is time to boot from it. Install macOS in the third drive. Boot to macOS and follow the post-install instructions to get it booting without the USB.  Set up BIOS Once all the systems are installed, you need to go to your BIOS options.\n Either press the [DEL] or [F2] key, depending on your system, when your manufacturer logo shows up on screen to get to the BIOS. Select OpenCore or the drive where you installed macOS as your default boot option and save changes.  Now every time you boot your computer you will be presented with a bootloader, letting you choose between your installations. You can improve how the bootloader looks by following this guide.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter.\n","permalink":"https://edfloreshz.blog/articles/tripleboot/","summary":"As developers, we sometimes require to test our software on different platforms, this can be hard to do especially if you don\u0026rsquo;t own a Mac, fortunately, there is a way to do exactly that","title":"How to triple-boot Windows, macOS and Linux?"},{"content":"That\u0026rsquo;s a pretty daring question considering Rust has been around for a fairly short amount of time and in that time has become the most loved language for 5 years in a row, according to the Stack Overflow Developer Surveys.\nIt is very clear that developers love working with Rust, many big companies have been adopting it to fix many of the memory issues C and C++ have caused by taking advantage of Rust\u0026rsquo;s memory safety capabilities. Microsoft recently started rewriting core components of Windows in Rust and the folks in charge of Linux have been talking about integrating Rust to the kernel. That\u0026rsquo;s a big step for Rust.\nBut the question remains\u0026hellip; should we trust Rust with the future of systems programming?\nRust is still a young language As much as it costs to admit, Rust is still a young language compared to C, which has been around for over 48 years and still is the preferred language for systems programming, every major operating system in the world is written in C/C++, as well as their drivers, utilities and built-in software.\nBut is Rust up to the challenge? Many developers have been rewriting software written in C with Rust, demonstrating that it is not only capable of competing with it but also of generating faster, more reliable software by taking advantage of Rust\u0026rsquo;s modern features.\nHere\u0026rsquo;s a small list of projects to check out:\n bat -\u0026gt; is a cat clone with syntax highlighting. exa -\u0026gt; is a modern replacement for ls. starship -\u0026gt; is a minimal, blazing-fast, and infinitely customizable prompt for any shell. ripgrep -\u0026gt; is an extremely fast alternative to grep  Operating systems written in Rust While having programs rewritten in Rust is pretty cool, being able to write low-level components is a must-have for a language that intends to become #1 for systems programming, things such as the kernel and drivers. There are no immediate plans to rewrite current operating systems in Rust, but there is a project created by Jeremy Soller, System76 Principal Engineer called RedoxOS.\n Redox is a Unix-like Operating System written in Rust, aiming to bring the innovations of Rust to a modern microkernel and full set of applications.\n Redox aims to demonstrate Rust\u0026rsquo;s systems programming capabilities to a full extent, having written not only the kernel in Rust but also every piece of software that it ships with it. One of those is relibc, a portable POSIX C standard library compatible with Redox and Linux. Redox isn\u0026rsquo;t currently going to replace your existing OS, but it\u0026rsquo;s a fun thing to try.\nRust still has a long way to go before it can compete with a language like C, but the future is looking very promising.\nRust is still missing some features While Rust has come a long way but it still lacks many of the features that C/C++ programmers take for granted, just to name a few:\nCompile-time code/type generation and verification -\u0026gt; Rust does have a procedural macro system that can be used to accomplish these things but it\u0026rsquo;s not remotely the same.\nStatic Analysis -\u0026gt; There may be more tools available for C++ but the quality of the static analysis built right into Rust\u0026rsquo;s type system blows all of them away, no tool can reliably prevent dangling references or data races in C++. As far as only using safe Rust, static analysis is in a way better shape than C++ because it has nothing as powerful as the borrow checker.\nSanitizers -\u0026gt; Due to the type system, safe Rust code has much less need for sanitizers, when it comes to unsafe code, C++ has the advantage as it has more tools available.\nThere\u0026rsquo;s also safe transmutation (safely cast \u0026ldquo;plain old data\u0026rdquo; types to and from raw bytes), safe support for C style unions, and fallible allocation (fail gracefully from allocation failure, rather than panic) as stated by Microsoft.\nConclusion As many missing features Rust has, its safe to say that, in time, Rust may become the language of choice for systems programming. Rust has an amazing community of developers that work hard every day to bring new features to the language, especially now that Microsoft supports Rust into becoming a better and more useful language.\n We at Microsoft will be able to help in these endeavors to shape the future of the language to improve its usefulness [\u0026hellip;].\n If you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter.\n","permalink":"https://edfloreshz.blog/articles/future/","summary":"The purpose of this article is to explore Rust in the systems programming.","title":"Should we trust Rust with the future of systems programming?"},{"content":"So here you are once again, procrastinating your time\u0026hellip; but not to worry, this article intends to help you get better at getting things done!\nIf you are passionate about programming you\u0026rsquo;ve probably started a side project by now, first you have an idea, it can go from building the next big thing to just building a simple to-do list, it doesn\u0026rsquo;t matter. You start really excited and throw in some code until a few days later it all falls apart, you\u0026rsquo;ve lost all interest or enthusiasm.\nHappens to me all the time, here are some tips I\u0026rsquo;ve encountered that have helped me stick with my side projects until they\u0026rsquo;re done!\nSatisfaction There are lots of reasons why people abandon projects, one of them is not feeling satisfied, feeling satisfied with a project is a big factor in whether or not you\u0026rsquo;ll stick with it.\nOf course, not every minute will be satisfying, but if the project itself is not satisfying, you might want to reflect on that for a bit, perhaps find a way to address that or perhaps move on to something that might be more satisfying for you.\nIf the project was satisfying before, try to find what changed. You can encourage yourself to feel more satisfied by reflecting on how much you\u0026rsquo;ve improved on a project, that can be very uplifting.\nRealistic Goals When starting a new project you set yourself a simple goal, once you progress towards that goal it starts to get more complicated, this is often when things start to feel unsatisfying.\nYou start to feel like you\u0026rsquo;re not progressing anymore, coming up with unrealistic goals is really easy.\nHow do we deal with that?\nAutomaticity  Automaticity is the ability to do things without occupying the mind with the low-level details required, allowing it to become an automatic response pattern or habit.\n With this in mind, forming habits that become automatic is one of the ways in which you can improve your productivity, perhaps not writing code but starting up your development environment as soon as you power your computer on, that may encourage you to continue working on your project.\nWhen to work? Most of us think of setting a fixed schedule and sticking with it, but this is an incredibly hard task to accomplish, considering that most of our day is ruled by events, not times.\nThink of these events as when you get out of the shower or eat breakfast, these events are more significant than fixed times throughout the day. These events are the times to schedule working on your project.\nPlanning Even when knowing you have to work, it can be hard to start doing it, but there\u0026rsquo;s a simple technique you can apply.\nLet\u0026rsquo;s say you want to start working out\n If I take a shower, I will get my workout clothes on in order to push myself to exercise.\n The idea is to get simple tasks into your routine so that the harder tasks get easier.\nNow let\u0026rsquo;s say you want to get work done\n If I log into my computer, I will open my text editor and project planner in order to get work done.\n That way it will be easier to get yourself writing code.\nGoals Be sure that your goals are specific, meaning that they\u0026rsquo;re very clear in what needs to be done. They should be measurable, meaning that it should be clear what\u0026rsquo;s required for it to be workable. Also achievable, meaning that it\u0026rsquo;s something that is not outside the roam of possibility, that it\u0026rsquo;s realistic and relevant, meaning that it\u0026rsquo;s something that you care about.\nSome extra advice Talk to friends in real life -\u0026gt; This can be a really good way to distract yourself for a moment when you are feeling frustrated about a problem you have.\nJoin friendly online communities -\u0026gt; This can be really helpful when having questions and finding people that can answer them.\nTake breaks -\u0026gt; You might come up with the solution to a problem you\u0026rsquo;ve been looking for just by lying in bed or making dinner.\nCelebrate little victories -\u0026gt; Make sure to celebrate when you accomplish something, no matter how small it is.\nConclusion Being a software developer is not an easy task, we are constantly facing new problems and dealing with insecurity within our ability to resolve those issues, these tips will help you improve in your ability to get things done and hopefully make you feel confident and prepared for what\u0026rsquo;s to come.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter.\n","permalink":"https://edfloreshz.blog/articles/tips/","summary":"In this article, we\u0026rsquo;ll be discussing some tips I\u0026rsquo;ve encountered that have helped me stick with my side projects until they\u0026rsquo;re done.","title":"Tips to deal with side projects"},{"content":"As new Rust developers, we constantly encounter new challenges, especially coming from languages like JavaScript or Python. Rust isn\u0026rsquo;t as familiar as other languages, but being a modern language it brings many benefits to the table that other older languages don\u0026rsquo;t.\nThe purpose of this article is to help Rust developers find tools and resources to make the most out of their developer experience. If you are reading this and Rust is not installed in your system head over to this website and install it.\nLearning Rust If you are new to Rust, you are going to want to read The Rust Book, which is a free book containing everything you need to know about the language, you can alternatively buy the book online if you prefer paperback books.\nReading the book will give you a better understanding of the design choices made by the Core Team and what are the differences of Rust in comparison to other languages, this will make it easier for you to get started writing code!\nAfter you are done with the book check the learning section on the Rust website, it contains many more resources for you to continue your journey into becoming a Rustancean.\nYou should also check out Jon Gjengset YouTube channel and join the Rust Discord server.\n This book assumes that you‚Äôve written code in another programming language, having personally read the book I can assure you that you don\u0026rsquo;t want to read this book as your first language unless you are very interested in systems development.\n Code Editor vs IDE Visual Studio Code When I started learning Rust I used Visual Studio Code, it is a fantastic code editor with a lot of extensibility, even to the point as making it work as a complete IDE, updates constantly bring new features and performance keeps getting better as Microsoft pushes Electron forward.\nAlthough my experience writing Rust code was good, it lacked some features other development tools like JetBrains CLion have, such as type inference and in-depth coding assistance which is very nice to have.\nNevertheless, my experience was really pleasant and I could comfortably go back to Visual Studio Code.\nRust extensions for Visual Studio Code  Rust Rust Grammar vscode-rust-syntax Better Toml rust-analyzer  Other Tools  Code Runner How to debug Rust in Visual Studio Code Error Handling  JetBrains CLion When I made the switch to CLion I immediately noticed a much better integration of the IDE with Rust. The Rust Plugin developed by JetBrains is the single piece of software that convinced me to switch from Visual Studio Code to CLion, here are some of the features that caught my eye.\n Right-click to create new files has Rust templates. The Cargo plugin allows you to run cargo commands with one click. Debugging is already integrated with the IDE. Preview the types of your variables as you write your code in real-time thanks to type inference.  Click here for a full list of features.\nPlugins  Toml  Of course, CLion is not free software, but you can get a free license if you are a student. If you are not a student you can still get a free or discounted license, alternatively you can buy CLion here.\nConclusion The resources in this article are not exhaustive, these are just some of the resources that helped me in my journey into becoming a Rustacean, it covers some of the best resources to learn Rust and how to set up your development environment to take full advantage of the tools we have available.\n If you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter.\n ","permalink":"https://edfloreshz.blog/articles/tools/","summary":"The purpose of this article is to help Rust developers find tools and resources to make the most out of their developer experience","title":"Best Development Tools And Resources For Rust"},{"content":"Eduardo Flores Hello, my name is Eddy.\nI\u0026rsquo;m a backend developer, I like to make small CLI apps like Sensei, usually in Rust. I have a cat and I practice archery on weekends.\nYou can find me on GitHub, Twitter and Telegram.\n","permalink":"https://edfloreshz.blog/about/","summary":"About me page","title":"About me"}]