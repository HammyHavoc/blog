<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Types In Rust | edfloreshz</title><meta name=keywords content><meta name=description content="In this article, we&rsquo;ll be discussing the various data types in Rust"><meta name=author content="Eduardo Flores"><link rel=canonical href=https://edfloreshz.github.io/blog/articles/datatypes/><link href=/assets/css/stylesheet.min.f580a29692e0c7eb72865ec0bd4ee916bef2dc7e85f4fbfdf6a609b3a0f4f6a1.css integrity="sha256-9YCilpLgx+tyhl7AvU7pFr7y3H6F9Pv99qYJs6D09qE=" rel="preload stylesheet" as=style><link rel=icon href=https://edfloreshz.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://edfloreshz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://edfloreshz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://edfloreshz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://edfloreshz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Data Types In Rust"><meta property="og:description" content="In this article, we&rsquo;ll be discussing the various data types in Rust"><meta property="og:type" content="article"><meta property="og:url" content="https://edfloreshz.github.io/blog/articles/datatypes/"><meta property="article:published_time" content="2020-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Data Types In Rust"><meta name=twitter:description content="In this article, we&rsquo;ll be discussing the various data types in Rust"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"https://edfloreshz.github.io/articles/"},{"@type":"ListItem","position":3,"name":"Data Types In Rust","item":"https://edfloreshz.github.io/blog/articles/datatypes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Data Types In Rust","name":"Data Types In Rust","description":"In this article, we\u0026amp;rsquo;ll be discussing the various data types in Rust","keywords":[],"articleBody":"In this article, we‚Äôll be discussing the various data types in Rust.\nRust differs from languages like Python or JavaScript in many ways, Rust is what‚Äôs known as a strongly typed language, this means that every variable must have a predefined data type bound to it at compile-time, in weakly typed languages, you don‚Äôt have to explicitly define them because it makes conversions between unrelated types implicitly. Of course, this comes at a cost, while weakly typed languages have many advantages, speed isn‚Äôt one of them.\n Compile time is the time at which the source code is converted into executable code.\n Every value in Rust is of a certain data type, this tells Rust what kind of data is being used and how to manage it. There are two types of data in Rust, scalar and compound.\nThe compiler can usually infer what data type we want to use based on the value we assign to it and how we use it. In cases when many types are possible, such as when we convert text to a numeric type, we must add a type annotation:\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\"); Type annotations are added by using : followed by the data type, in this case u32, after the variable name. If we don‚Äôt add the type annotation here, we‚Äôll get a compiler error:\nerror[E0282]: type annotations needed -- src/main.rs:2:9 | 2 | let guess = \"42\".parse().expect(\"Not a number!\"); | ^^^^^ consider giving `guess` a type Scalar Types A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You might recognize these from other languages.\nInteger Types An integer is a number without a fractional component. Integers can be divided into two types: signed and unsigned.\nA signed integer is an integer that can be both positive and negative. This is as opposed to an unsigned integer, which can only be positive. Integers are represented as bytes, one byte is equivalent to 8 bits, which is the basic unit of information in computing.\nIn Rust, we have the following data types:\n   Length Signed Unsigned     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128    Each number represents the number of bits that can be allocated in that data type, for instance, when we declare a variable with u8, we are saying that our variable will not have negative numbers and can store up to 8 bits of information.\nEach signed variant can store numbers from -(2^(n - 1)) to 2^(n - 1) - 1 inclusive, where n is the number of bits that variant uses. So an i8 can store numbers from -(2^7) to 2^7 - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2^(n) - 1, so a u8 can store numbers from 0 to 2^(8) - 1, which equals 0 to 255.\n   Length From To     i8 -128 127   u8 0 255   i16 -32,768 32,767   u16 0 65,535    You can calculate the remaining ranges using Wolfram Alpha, just replace n in the equation with the number of bytes that the remaining data types can store.\nAdditionally, the isize and usize types depend on the kind of computer your program is running on: 64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-bit architecture.\nInteger Literals You can write integer literals in any of the forms shown in the next table. Note that all number literals except the byte literal allow a type suffix, such as 57u8, and _ as a visual separator, such as 1_000.\n   Number literals Example     Decimal 98_222   Hex 0xff   Octal 0o77   Binary 0b1111_0000   Byte u8 only b'A'    Integer Overflow Let‚Äôs say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur. An integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits.\nWhen you‚Äôre debugging your app, this will cause it to panic and exit, but if this code is compiled as -- release, two‚Äôs complement wrapping will occur. This means that values greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the minimum of the values the type can hold. In the case of a u8, 256 becomes 0, 257 becomes 1, and so on.\nFloating-Point Types Rust also has two primitive types for floating-point numbers, which are numbers with decimal points, f32 and f64. Here‚Äôs how you declare a variable of type floating-point.\nfn main() { let x = 2.0; // Rust can infer this is of type f64 when we use a decimal point.  let y: f32 = 3.0; // We need to specify it as f32 because f64 is the default. } The Boolean Type The boolean type, as in most programming languages, has only two possible values, true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool.\nfn main() { let t = true; let f: bool = false; // with explicit type annotation } You can also declare boolean types by using logical operators.\nfn main() { let yes = true || true; let no = true \u0026\u0026 false; println!(\"{} and {}\", yes, no); // true and false } The Character Type Rust doesn‚Äôt only work with numbers, it has letters too!\nfn main() { let c = 'z'; let z = '‚Ñ§'; let heart_eyed_cat = 'üòª'; } Rust‚Äôs char type is the language‚Äôs most primitive alphabetic type, are four bytes in size, and represent a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust.\nNote that char literals are specified with single quotes, as opposed to string literals, which use double-quotes.\nNumeric Operations Rust supports the basic mathematical operations you‚Äôd expect for all of the number types: addition, subtraction, multiplication, division, and remainder.\nThe following example shows how to use all of them:\nfn main() { // addition  let sum = 5 + 10; // subtraction  let difference = 95.5 - 4.3; // multiplication  let product = 4 * 30; // division  let quotient = 56.7 / 32.2; // remainder  let remainder = 43 % 5; } Compound Types Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.\nThe Tuple Type A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.\nWe create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don‚Äôt have to be the same.\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {}\", y); // 6.4 } This program first creates a tuple and binds it to the variable tup. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.\nIn addition to destructuring through pattern matching, we can access a tuple element directly by using a period . followed by the index of the value we want to access. For example:\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; // 500  let six_point_four = x.1; // 6.4  let one = x.2; // 1 } The Array Type Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type.\nIn Rust, the values going into an array are written as a comma-separated list inside square brackets:\nfn main() { let a = [1, 2, 3, 4, 5]; let months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]; } Arrays are useful when you want your data allocated on the stack rather than the heap (you can learn more about this here) or when you want to ensure you always have a fixed number of elements.\nYou would write an array‚Äôs type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:\nlet a: [i32; 5] = [1, 2, 3, 4, 5]; Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\nAccessing Array Elements An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; // 1  let second = a[1]; // 2 } In this example, the variable named first will get the value 1, because that is the value at index [0] in the array. The variable named second will get the value 2 from index [1] in the array.\nInvalid Array Element Access What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:\nfn main() { let a = [1, 2, 3, 4, 5]; let index = 10; let element = a[index]; println!(\"The value of element is: {}\", element); } Running this code using cargo run produces the following result:\n$ cargo run Compiling arrays v0.1.0 (file:///projects/arrays) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/arrays` thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace. The compilation didn‚Äôt produce any errors, but the program resulted in a runtime error and didn‚Äôt exit successfully. When you attempt to access an element using indexing, Rust will check that the index you‚Äôve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.\nThis is the first example of Rust‚Äôs safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.\nWhat‚Äôs next? In the next article, we‚Äôll talk about functions to provide better modularity for your application.\nIf you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to @me on Twitter or send me a message.\n","wordCount":"1900","inLanguage":"en","datePublished":"2020-09-25T00:00:00Z","dateModified":"2020-09-25T00:00:00Z","author":{"@type":"Person","name":"Eduardo Flores"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://edfloreshz.github.io/blog/articles/datatypes/"},"publisher":{"@type":"Organization","name":"edfloreshz","logo":{"@type":"ImageObject","url":"https://edfloreshz.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://edfloreshz.github.io accesskey=h title="edfloreshz (Alt + H)">edfloreshz</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Data Types In Rust</h1><div class=post-meta>September 25, 2020&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;Eduardo Flores</div></header><div class=post-content><p>In this article, we&rsquo;ll be discussing the various data types in Rust.</p><p>Rust differs from languages like Python or JavaScript in many ways, Rust is what&rsquo;s known as a strongly typed language, this means that every variable must have a predefined data type bound to it at compile-time, in weakly typed languages, you don&rsquo;t have to explicitly define them because it makes conversions between unrelated types implicitly. Of course, this comes at a cost, while weakly typed languages have many advantages, speed isn&rsquo;t one of them.</p><blockquote><p><strong>Compile time</strong> is the time at which the source code is converted into executable code.</p></blockquote><p>Every value in Rust is of a certain <em>data type</em>, this tells Rust what kind of data is being used and how to manage it. There are two types of data in Rust, <strong>scalar</strong> and <strong>compound</strong>.</p><p>The compiler can usually infer what data type we want to use based on the value we assign to it and how we use it. In cases when many types are possible, such as when we convert text to a numeric type, we must add a type annotation:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> guess: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;42&#34;</span>.parse().expect(<span style=color:#e6db74>&#34;Not a number!&#34;</span>);
</code></pre></div><p>Type annotations are added by using <code>:</code> followed by the data type, in this case <code>u32</code>, after the variable name. If we don‚Äôt add the type annotation here, we&rsquo;ll get a compiler error:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>error<span style=color:#f92672>[</span>E0282<span style=color:#f92672>]</span>: type annotations needed
 --&gt; src/main.rs:2:9
  |
<span style=color:#ae81ff>2</span> |     let guess <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;42&#34;</span>.parse<span style=color:#f92672>()</span>.expect<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Not a number!&#34;</span><span style=color:#f92672>)</span>;
  |         ^^^^^ consider giving <span style=color:#e6db74>`</span>guess<span style=color:#e6db74>`</span> a type
</code></pre></div><h1 id=scalar-types>Scalar Types<a hidden class=anchor aria-hidden=true href=#scalar-types>#</a></h1><p>A <strong>scalar</strong> type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You might recognize these from other languages.</p><h2 id=integer-types>Integer Types<a hidden class=anchor aria-hidden=true href=#integer-types>#</a></h2><p>An integer is a number without a fractional component. Integers can be divided into two types: <strong>signed</strong> and <strong>unsigned</strong>.</p><p>A signed integer is an integer that can be both positive and negative. This is as opposed to an unsigned integer, which can only be positive. Integers are represented as bytes, one byte is equivalent to 8 bits, which is the basic unit of information in computing.</p><p>In Rust, we have the following data types:</p><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr></tbody></table><p>Each number represents the number of bits that can be allocated in that data type, for instance, when we declare a variable with <code>u8</code>, we are saying that our variable will not have negative numbers and can store up to 8 bits of information.</p><p>Each signed variant can store numbers from <code>-(2^(n - 1)) to 2^(n - 1) - 1</code> inclusive, where <code>n</code> is the number of bits that variant uses. So an i8 can store numbers from <code>-(2^7) to 2^7 - 1</code>, which equals <code>-128</code> to <code>127</code>. Unsigned variants can store numbers from <code>0</code> to <code>2^(n) - 1</code>, so a <code>u8</code> can store numbers from <code>0</code> to <code>2^(8) - 1</code>, which equals <code>0</code> to <code>255</code>.</p><table><thead><tr><th>Length</th><th>From</th><th>To</th></tr></thead><tbody><tr><td>i8</td><td><code>-128</code></td><td><code>127</code></td></tr><tr><td>u8</td><td><code>0</code></td><td><code>255</code></td></tr><tr><td>i16</td><td><code>-32,768</code></td><td><code>32,767</code></td></tr><tr><td>u16</td><td><code>0</code></td><td><code>65,535</code></td></tr></tbody></table><p>You can calculate the remaining ranges using <a href=https://www.wolframalpha.com/>Wolfram Alpha</a>, just replace <code>n</code> in the equation with the number of bytes that the remaining data types can store.</p><p>Additionally, the <code>isize</code> and <code>usize</code> types depend on the kind of computer your program is running on: 64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-bit architecture.</p><h4 id=integer-literals>Integer Literals<a hidden class=anchor aria-hidden=true href=#integer-literals>#</a></h4><p>You can write integer literals in any of the forms shown in the next table. Note that all number literals except the byte literal allow a type suffix, such as 57u8, and _ as a visual separator, such as 1_000.</p><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte <code>u8 only</code></td><td><code>b'A'</code></td></tr></tbody></table><h4 id=integer-overflow>Integer Overflow<a hidden class=anchor aria-hidden=true href=#integer-overflow>#</a></h4><p>Let‚Äôs say you have a variable of type <code>u8</code> that can hold values between <code>0</code> and <code>255</code>. If you try to change the variable to a value outside of that range, such as <code>256</code>, <strong>integer overflow</strong> will occur. An integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits.</p><p>When you&rsquo;re debugging your app, this will cause it to <code>panic</code> and exit, but if this code is compiled as <code>-- release</code>, <em>two‚Äôs complement wrapping</em> will occur. This means that values greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the minimum of the values the type can hold. In the case of a <code>u8</code>, 256 becomes 0, 257 becomes 1, and so on.</p><h2 id=floating-point-types>Floating-Point Types<a hidden class=anchor aria-hidden=true href=#floating-point-types>#</a></h2><p>Rust also has two primitive types for floating-point numbers, which are numbers with decimal points, <code>f32</code> and <code>f64</code>. Here&rsquo;s how you declare a variable of type floating-point.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>; <span style=color:#75715e>// Rust can infer this is of type f64 when we use a decimal point.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>; <span style=color:#75715e>// We need to specify it as f32 because f64 is the default.
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=the-boolean-type>The Boolean Type<a hidden class=anchor aria-hidden=true href=#the-boolean-type>#</a></h2><p>The boolean type, as in most programming languages, has only two possible values, <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in Rust is specified using <code>bool</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
    <span style=color:#66d9ef>let</span> f: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// with explicit type annotation
</span><span style=color:#75715e></span>}
</code></pre></div><p>You can also declare boolean types by using logical operators.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> yes <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>true</span>;
    <span style=color:#66d9ef>let</span> no <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>false</span>;

    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{} and {}&#34;</span>, yes, no); <span style=color:#75715e>// true and false
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=the-character-type>The Character Type<a hidden class=anchor aria-hidden=true href=#the-character-type>#</a></h2><p>Rust doesn&rsquo;t only work with numbers, it has letters too!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;z&#39;</span>;
    <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;‚Ñ§&#39;</span>;
    <span style=color:#66d9ef>let</span> heart_eyed_cat <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;üòª&#39;</span>;
}
</code></pre></div><p>Rust‚Äôs char type is the language‚Äôs most primitive alphabetic type, are four bytes in size, and represent a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust.</p><p>Note that <code>char</code> literals are specified with single quotes, as opposed to <code>string</code> literals, which use double-quotes.</p><h2 id=numeric-operations>Numeric Operations<a hidden class=anchor aria-hidden=true href=#numeric-operations>#</a></h2><p>Rust supports the basic mathematical operations you‚Äôd expect for all of the number types: addition, subtraction, multiplication, division, and remainder.</p><p>The following example shows how to use all of them:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// addition
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>;
    <span style=color:#75715e>// subtraction
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> difference <span style=color:#f92672>=</span> <span style=color:#ae81ff>95.5</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>4.3</span>;
    <span style=color:#75715e>// multiplication
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> product <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>30</span>;
    <span style=color:#75715e>// division
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> quotient <span style=color:#f92672>=</span> <span style=color:#ae81ff>56.7</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>32.2</span>;
    <span style=color:#75715e>// remainder
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> remainder <span style=color:#f92672>=</span> <span style=color:#ae81ff>43</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span>;
}

</code></pre></div><h1 id=compound-types>Compound Types<a hidden class=anchor aria-hidden=true href=#compound-types>#</a></h1><p>Compound types can group multiple values into one type. Rust has two primitive compound types: <strong>tuples</strong> and <strong>arrays</strong>.</p><h2 id=the-tuple-type>The Tuple Type<a hidden class=anchor aria-hidden=true href=#the-tuple-type>#</a></h2><p>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p><p>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don‚Äôt have to be the same.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
}
</code></pre></div><p>To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> tup <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>let</span> (x, y, z) <span style=color:#f92672>=</span> tup;
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The value of y is: {}&#34;</span>, y);  <span style=color:#75715e>// 6.4
</span><span style=color:#75715e></span>}
</code></pre></div><p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of <code>y</code>, which is <code>6.4</code>.</p><p>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period <code>.</code> followed by the index of the value we want to access. For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> x: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>let</span> five_hundred <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 500
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> six_point_four <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 6.4
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> one <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>2</span>; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>}

</code></pre></div><h2 id=the-array-type>The Array Type<a hidden class=anchor aria-hidden=true href=#the-array-type>#</a></h2><p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type.</p><p>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
    <span style=color:#66d9ef>let</span> months <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;January&#34;</span>, <span style=color:#e6db74>&#34;February&#34;</span>, <span style=color:#e6db74>&#34;March&#34;</span>, <span style=color:#e6db74>&#34;April&#34;</span>, <span style=color:#e6db74>&#34;May&#34;</span>, <span style=color:#e6db74>&#34;June&#34;</span>, <span style=color:#e6db74>&#34;July&#34;</span>,
              <span style=color:#e6db74>&#34;August&#34;</span>, <span style=color:#e6db74>&#34;September&#34;</span>, <span style=color:#e6db74>&#34;October&#34;</span>, <span style=color:#e6db74>&#34;November&#34;</span>, <span style=color:#e6db74>&#34;December&#34;</span>];
}
</code></pre></div><p>Arrays are useful when you want your data allocated on the <strong>stack</strong> rather than the <strong>heap</strong> (you can learn more about this <a href=https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html>here</a>) or when you want to ensure you always have a fixed number of elements.</p><p>You would write an array‚Äôs type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</code></pre></div><p>Here, <code>i32</code> is the type of each element. After the semicolon, the number <code>5</code> indicates the array contains five elements.</p><h4 id=accessing-array-elements>Accessing Array Elements<a hidden class=anchor aria-hidden=true href=#accessing-array-elements>#</a></h4><p>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];

    <span style=color:#66d9ef>let</span> first <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>0</span>]; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> second <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>1</span>]; <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>}
</code></pre></div><p>In this example, the variable named <code>first</code> will get the value 1, because that is the value at index <code>[0]</code> in the array. The variable named <code>second</code> will get the value <code>2</code> from index <code>[1]</code> in the array.</p><h4 id=invalid-array-element-access>Invalid Array Element Access<a hidden class=anchor aria-hidden=true href=#invalid-array-element-access>#</a></h4><p>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
    <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;

    <span style=color:#66d9ef>let</span> element <span style=color:#f92672>=</span> a[index];

    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The value of element is: {}&#34;</span>, element);
}
</code></pre></div><p>Running this code using cargo run produces the following result:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cargo run
   Compiling arrays v0.1.0 <span style=color:#f92672>(</span>file:///projects/arrays<span style=color:#f92672>)</span>
    Finished dev <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.31s
     Running <span style=color:#e6db74>`</span>target/debug/arrays<span style=color:#e6db74>`</span>
thread <span style=color:#e6db74>&#39;main&#39;</span> panicked at <span style=color:#e6db74>&#39;index out of bounds: the len is 5 but the index is 10&#39;</span>, src/main.rs:5:19
note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace.
</code></pre></div><p>The compilation didn‚Äôt produce any errors, but the program resulted in a runtime error and didn‚Äôt exit successfully. When you attempt to access an element using indexing, Rust will check that the index you‚Äôve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</p><p>This is the first example of Rust‚Äôs safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.</p><h1 id=whats-next>What&rsquo;s next?<a hidden class=anchor aria-hidden=true href=#whats-next>#</a></h1><p>In the next article, we&rsquo;ll talk about <a href=/articles/functions>functions</a> to provide better modularity for your application.</p><p>If you enjoyed this article, consider sharing it so more people can benefit from it! Also, feel free to <a href=https://twitter.com/edfloreshz>@me</a> on Twitter or send me a <a href=https://t.me/edfloreshz>message</a>.</p></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on twitter" href="https://twitter.com/intent/tweet/?text=Data%20Types%20In%20Rust&url=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f&title=Data%20Types%20In%20Rust&summary=Data%20Types%20In%20Rust&source=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f&title=Data%20Types%20In%20Rust"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on whatsapp" href="https://api.whatsapp.com/send?text=Data%20Types%20In%20Rust%20-%20https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data Types In Rust on telegram" href="https://telegram.me/share/url?text=Data%20Types%20In%20Rust&url=https%3a%2f%2fedfloreshz.github.io%2fblog%2farticles%2fdatatypes%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://edfloreshz.github.io>edfloreshz</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>